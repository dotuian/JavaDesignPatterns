基础知识：
栈内存主要保存以下内容：基本数据类型和对象的引用，而堆内存存储对象，栈内存的速度要快于堆内存。
总结成一句话就是：引用在栈而对象在堆。 




装饰模式： 与所装饰的对象具有相同的接口。装饰模式为所装饰的对象提供增强功能。

适配器模式：


===========================
创建模式
===========================
+ 简单工厂模式：
   简单工厂模式是类的创建模式，又叫做静态工厂方法模式。是由一个工厂对象决定创建出哪一种产品类的实例。
  
+ 工厂方法模式
  定义一个创建对象的工厂接口，将实际的创建推迟到子类当中。
  
+ 抽象工厂模式
  抽象工厂模式可以向客户端提供一个接口，使得客户端在补习指定产品的具体类型的情况下，创建多个产品族中的产品对象。
  
+ 单例模式
 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

+ 多例模式
  多例类可以有多个实例。
  多例类必须自己创建，管理自己的实例，并向外界提供自己的实例。
  
+ 建造模式（Builder）
 建造模式是对象的创建模式，建造模式可以将一个产品的内部表象与产品的生成过程分割开来，
 从而使一个建造过程可以生成具有不同的内部表象的产品对象。

+ 原始模型模式（Prototype）
 原始模型模式属于对象的创建模式，通过给出一个原型对象来指明所要创建对象的类型，
 然后用复制这个原型对象的拌饭创建出更多同类型的对象。这就是原始模型模式的用意。


===========================
结构模式
===========================
+ 适配器模式（Adapter）
 适配器模式把一个类的接口变成客户端所期待的另一种接口，从而使原本因接口不匹配而无法再一起工作的两个类能够在一起工作。
 
+ 缺省适配模式（Default Adapter）
 缺省适配模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。
 作为适配器模式的一个特例，缺省适配模式在Java语言中有着特殊的应用。

+ 合成模式（Composite）
 合成模式属于对象的结构模式，有时候又叫做部分--整体模式，合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。
 合成模式可以使客户端将单纯元素与复合元素同等看待。

+ 装饰模式（Decorator）
 装饰模式又叫包装模式（Wrapper），是对象的结构模式。
 装饰模式对客户端透明的方式将一个对象的功能加以扩展，装饰模式为功能的扩展提供了一个除继承关系之外的另一个可选方案。
 
+ 代理模式（Proxy）
 代理模式对对象的结构模式。
 代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
 
+ 享元模式（Flyweight）
 享元模式是对象的结构模式。
 享元模式以共享的方式高效地支持大量的细粒度对象。

+ 门面模式（Facade）
 门面模式是对象的结构模式。外部与一个子系统的通信必须通过一个统一门面对象进行，这就是门面模式。
 门面模式提供了一个高层次的接口，使得子系统更易于使用。

+ 桥梁模式（Bridge）
 桥梁模式是对象的结构模式，又称为接口模式。
 桥梁模式是将抽象化（Aabstraction）与实现化（Implmentation）脱耦，使得两者可以独立地变化。

===========================
行为模式： 对不同对象之间划分责任和算法的抽象化。
===========================
+ 不变模式 
 一个对象的状态在被创建之后就不在变化。
 
+ 策略模式（Strategy）
 策略模式属于对象的行为模式。
 策略模式的用意是：准备一组算法，并将每个算法封装到一个独立的具体类中。这些具体类有共同的接口，
 从而使得他们可以互换。策略模式使得算法可以在不影响客户端的情况下发生变化。
 
+ 模板方法模式（Template Method）
 模板方法模式是类的行为模式。
 准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，
 然后声明一些抽象方法来迫使子类实现剩余的逻辑。
 不同的子类可以以不同的方法实现这些抽象方法，从而对剩余的逻辑有不同的实现。
 
+ 观察者模式（Observer）
 观察者是对象的行为模式，又叫做“发布--订阅模式”。
 观察者定义了一种一对多的依赖关系，让多个观察者同时监听某一个主题对象，这个主题对象在状态上发生变化是，
 会通知所有观察者对象，使得它们能够主动更新自己。
 
 + 迭代子模式(Iterator)
 迭代子模式又叫做游标模式，是对象的行为模式。
 迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。

+ 责任链模式（Chain Of Responsibility）
 责任链模式是一种对象的行为模式。
 在责任链模式中，很多对象由每一个对象对其下家的引用而连接起来形成一条链，请求在这个链上进行传递，
 知道链上某一个对象决定处理此请求。
 发出这个请求的客户端并不知道链上哪一个对象最终处理这个请求。
 这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。
 
 + 命令模式（Command）
 命令模式属于对象的行为模式，命令模式又称为行动模式（Action）或交易模式（Transaction）。
 命令模式把一个请求或者操作封装到一个对象中。
 命令模式允许系统使用不同的请求把客户端参数化，对请求排队或记录请求日志。
 可以提供命令的撤销和恢复功能。

+ 备忘录模式（Memonto）
备忘录模式又叫做快照模式，或Token模式。是对象的行为模式。
备忘录模式的用意是：在不破坏封装的条件下，将一个对象的状态捕捉住，并外部化存储起来，
从而可以在将来合适的时候把这个对象还原到存储起来的状态。

+ 状态模式（State）
状态模式又称为状态对象模式，是对象的行为模式。
状态模式允许一个对象在其内部状态改变的时候，改变其行为。这个看上去就像是改变了的类一样。

+ 访问者模式（Visitor）
访问者模式是对象的行为模式。
访问者模式的目的是：封装一些施加于某种数据结构元素之上的操作。
一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。

+ 解释器模式（Interpreter）
 解释器模式是类的行为模式。
 给定一个语言之后，解释器模式可以定义出其文法的一种表示，
 并同时提供一个解释器。可以断可以使用这个解释器来解释这个语言中的句子，
 
+ 调停者模式（Mediator）
调停者模式是对象的行为模式。
调停者模式包装了一系列对象互相作用的方式，使得这些对象不必互相明显引用，
从而使他们可以较轻松散地耦合。当这些对象中的某些对象之间互相作用发生改变时，
不会立即影响到其他的一些对象之间的互相作用，
从而保证这些互相作用可以彼此独立地变化。


















